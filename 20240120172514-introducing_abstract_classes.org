:PROPERTIES:
:ID:       a1091361-fe51-4d9a-97dc-1178bc14226e
:END:
#+title: Introducing Abstract Classes
#+property: header-args :tangle code/ocp/6/introducing_abstract_classes.java

* Introducing Abstract Classes

An ~abstract class~ is a class declared with the ~abstract~ modifier that *cannot* be *instantiated* directly and may contain [[id:3e6ed9f7-a719-4f68-94f0-29cb4914ebf2][abstract methods]].

An ~abstract class~ is most commonly used when you want *another* ~class~ to *inherit* properties of a particular class, but you want the ~subclass~ to fill in some of the *implementation details*.

** Example

#+BEGIN_SRC java
public abstract class Canine {}

public class Wolf extends Canine {}
public class Fox extends Canine {}
public class Coyote extends Canine {}
#+END_SRC

An ~abstract class~ can contain [[id:3e6ed9f7-a719-4f68-94f0-29cb4914ebf2][abstract methods]].

An [[id:3e6ed9f7-a719-4f68-94f0-29cb4914ebf2][abstract methods]] is a method declared with the ~abstract~ modifier that does not define a body.
Put another way, an [[id:3e6ed9f7-a719-4f68-94f0-29cb4914ebf2][abstract methods]] *forces* ~subclasses~ to *override* the method.

Why would we want this? [[id:737de690-076a-4f7f-91f5-606587c75882][polymorphism]], of course!

By declaring a method ~abstract~, we can *guarantee* that some version will be available on an =instance= without having to specify what that version is in the ~abstract parent~ class

** Example

#+BEGIN_SRC java
public abstract class Canine {
    public abstract String getSound();
    public void bark() {
        System.out.println(getSound());
    }
}

public class Wolf extends Canine {
    public String getSound() {
        return "Wooooooof!";
    }
}

public class Fox extends Canine {
    public String getSound() {
        return "Squeak!";
    }
}

public class Coyote extends Canine {
    public String getSound() {
        return "Roar!";
    }
}

public static void main(String[] p) {
    Canine w = new Fox();
    w.bark(); // Squeak!
}
#+END_SRC

** Rules

- Only ~instance~ methods can be marked abstract within a class, not variables, =constructors=, or static methods.

- An [[id:3e6ed9f7-a719-4f68-94f0-29cb4914ebf2][abstract methods]] can only be declared in an ~abstract class~.

- A *nonÂ­abstract* ~class~ that extends an ~abstract class~ *must* implement all *inherited* [[id:3e6ed9f7-a719-4f68-94f0-29cb4914ebf2][abstract methods]].

- *Overriding* an [[id:3e6ed9f7-a719-4f68-94f0-29cb4914ebf2][abstract methods]] follows the existing rules for [[id:c67b24a4-82f7-4423-83a9-75fc1c566166][overriding methods]].

** _Exam Trick_

If you attempt to instantiate it, the compiler will report an *exception*:

#+BEGIN_SRC java
abstract class Alligator {
    public static void main(String... food) {
        var a = new Alligator(); // DOES NOT COMPILE
    }
}
#+END_SRC

An abstract class can be *initialized*, but only as part of the *instantiation* of a *non-abstract* ~subclass~.
