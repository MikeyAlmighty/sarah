:PROPERTIES:
:ID:       f186ce91-693f-4f94-a382-f89915b76fd4
:END:
#+title: Linked List
#+property: header-args :tangle code/datastructures/LinkedList.js
#+filetags: :DataStructure:

* Linked List
** Complexity
| Operation | Average Case | Worst Case |
|-----------+--------------+------------|
| Search    | O(n)         | O(n)       |
| Insert    | O(1)         | O(1)       |
| Delete    | O(1)         | O(1)       |


|           | Array                           | Linked List                                                                 |
|-----------+---------------------------------+-----------------------------------------------------------------------------|
| Strengths | Random Access (Fast Search).    | Fast Insertion/Deletion time.                                               |
|           | Less memory needed per element. | Dynamic Size.                                                               |
|           | Better cache locality           | Efficient memory allocation/utilization                                     |
|-----------+---------------------------------+-----------------------------------------------------------------------------|
| Weakness  | Slow Insertion/Deletion time    | Slow Search Time                                                            |
|           | Fixed size                      | More memory needed per node as additional storage is required for pointers. |
|           |                                 |                                                                             |


Made up of many nodes.

A => B => C => D => Null
- A = Head
- D = Tail

=Node= - Contains some data, and an index.
- Insertion is in Constant O(1) time [Faster than an [Array](./Arrays.md)]

If you want to pass a =linkedList= to a function, you can just pass the Head node.
It contains a `current.next` method for the next node in the list, continuing all the way to the tail (When current = null is hit).


When writing logic (i.e traversal) for a linkedList, try and work with `current`

[[https://www.youtube.com/watch?v=Hj_rA0dhr2I][Linked Lists for Technical Interviews - Full Course]]

#+BEGIN_SRC js
class Node {
  constructor(val){
    this.val = val
    this.next = null
  }
}

// Simply prints the linkedList values
const iterativePrintLinkedList = (headNode) => {
  let current = headNode
// When writing logic (I.e traversal) for a linkedList, try and work with `current`, NOT current.next === null as it will exclude the tail
  while (current !== null){
    console.log(current.val)
    current = current.next
  }
}

// Simply prints the linkedList values
const recursivePrintLinkedList = (headNode) => {
  if (headNode === null) return
  console.log(headNode.val)
  recursivePrintLinkedList(headNode.next)
}

// Retrieves the linkedList values inside an array
const iterativetGetLinkedListValues = (headNode) => {
  const result = []
  let current = headNode
  while (current !== null) {
    result.push(current.val)
    current = current.next
  }
  return result
}

// Retrieves the linkedList values inside an array
const recursiveGetLinkedListValues = (headNode) => {
  const result = []
  fillValues(headNode, result)
  return result
}
const fillValues = (head, values) => {
  if (head === null) return
  values.push(head.val)
  fillValues(head.next, values)
}

// Returns the Sum of each node's value.
const sumLinkedList = (headNode) => {
  let sumResult = 0
  let current = headNode
  while (current !== null) {
    sumResult += current.val
   current = current.next
  }
  return sumResult
}

// Returns boolean if List contains target value
const linkedListContains = (headNode, target) => {
  let current = headNode
  while (current !== null) {
    if (current.val === target) return true
    current = current.next
  }
  return false
}

// Retrieves the value at the given targetIndex
const valueAtIndex = (headNode, targetIndex) => {
  let currentIndex = 0
  let current = headNode
  while (current !== null) {
    if (currentIndex === targetIndex) return current.val
    currentIndex += 1
    current = current.next
  }
}

// A -> B -> C
// 1st prev = null, next = B,

// Reverse linkedList - has O(1) space complexity as it only requires variable assignments
const iterativeReverseLinkedList = (headNode) => {
  let prev = null
  let current = headNode
  while (current !== null) {
    const next = current.next // Store next node
    current.next = prev  // Set next node to previous node
    prev = current // set Previous node to current node
    current = next // Set current Node to next node for following iteration
  }
  return prev
}

// Reverse linkedList - Higher O(n) space complexity
const recursiveReverseLinkedList = (headNode, prev = null) => {
  if (headNode === null) return prev
  const next = headNode.next
  recursiveReverseLinkedList(next, headNode)
}

const iterativeZipperList = (head1, head2) => {
  let tail = head1;
  let current1 = head1;
  let current2 = head2;
  let count = 0;

  while (current1 !== null && current2 !== null) {
    if (count % 2 === 0) {
      tail.next = current2;
      current2 = current2.next;
    } else {
      tail.next = current1;
      current1 = current1.next;
    }
    tail = tail.next;
    count += 1;
  }
  if (current1 !== null) tail.next = current1;
  if (current2 !== null) tail.next = current2;
  return tail;
}

const recursiveZipperList = (head1, head2) => {
  if (head1 === null && head2 === null) return null // Base case
  if (head1 === null) return head2
  if (head2 === null) return head1

  const next1 = head1.next
  const next2 = head2.next

  head1.next = head2
  head2.next = recursiveZipperList(next1, next2)
  return head1
}


const a = new Node('A')
const b = new Node('B')
const c = new Node('C')
const d = new Node('D')

a.next = b
b.next = c
c.next = d

const num1 = new Node(27)
const num2 = new Node(69)
const num3 = new Node(420)
const num4 = new Node(4)

num1.next = num2
num2.next = num3
num3.next = num4

iterativePrintLinkedList(a)
recursivePrintLinkedList(a)

console.log(iterativetGetLinkedListValues(a))
console.log(recursiveGetLinkedListValues(a))
console.log(sumLinkedList(num1))
console.log(linkedListContains(num1, 420)) // Should return true
console.log(linkedListContains(a, 'G')) // Should return false
console.log(valueAtIndex(a, 2)) // Should return C
console.log(valueAtIndex(num1, 3)) // Should return 4
console.log(iterativeReverseLinkedList(num1))
console.log(recursiveReverseLinkedList(num1))
console.log(iterativeZipperList(a, num1))
// console.log(recursiveZipperList(a, num1))
#+END_SRC
